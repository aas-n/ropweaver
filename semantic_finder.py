import re
from utils import remove_ansi_codes, debug_print

def find_shortest_gadget(categories, category, pattern_template, debug, **kwargs):
    """
    Finds the shortest gadget matching the pattern in a specified category.
    The pattern is dynamically generated by filling in `pattern_template` with `kwargs`.
    """
    # Generate the final pattern by filling in placeholders in the template
    pattern = pattern_template.format(**kwargs)
    
    shortest_gadget = None
    min_instructions = float('inf')

    if category not in categories:
        debug_print(f"[DEBUG] Category '{category}' not found.", debug)
        return None

    for gadget in categories[category]:
        clean_gadget = remove_ansi_codes(gadget)
        debug_print(f"[DEBUG] Checking gadget: {clean_gadget} with pattern: {pattern}", debug)

        # Check if the gadget matches the pattern
        if re.search(pattern, clean_gadget):
            instruction_count = clean_gadget.count(";")
            if instruction_count < min_instructions:
                min_instructions = instruction_count
                shortest_gadget = gadget
                debug_print(f"[DEBUG] New shortest gadget found: {shortest_gadget} with {instruction_count} instructions", debug)

    return shortest_gadget

def find_semantic_gadgets(categories, semantic, debug):
    """Searches for the gadget or chain of gadgets matching the specified semantic."""
    debug_print(f"[DEBUG] Processing semantic: {semantic}", debug)
    
    # Define patterns for each semantic type
    patterns = {
        r"\[(\w+)\]\s*<-\s*(\w+)": (".: [REG1] <- REG2 gadgets :.", r".*mov (dword ptr\s*)?\[{dest}\], {src}.* ret;?"),
        r"(\w+)\s*<-\s*\[(\w+)\]": (".: REG1 <- [REG2] gadgets :.", r".*mov {dest}, \[{src}\].* ret;?"),
        r"(\w+)\s*<-\s*(\w+)": (".: REG1 <- REG2 gadgets :.", r".*mov {dest}, {src}.* ret;?"),
        r"(\w+)\s*<->\s*(\w+)": (".: REG1 <-> REG2 gadgets :.", r".*xchg {dest}, {src}.* ret;?"),
        r"(\w+)\s*\+\s*(\w+)": (".: REG1 + REG2 gadgets :.", r".*add {dest}, {src}.* ret;?"),
        r"(\w+)\s*-\s*(\w+)": (".: REG1 - REG2 gadgets :.", r".*sub {dest}, {src}.* ret;?"),
        r"(\w+)\s*<- 0": (".: REG <- 0 gadgets :.", r".*xor {dest}, {dest}.* ret;?"),
        r"(\w+)\s*\+\+": (".: REG++ gadgets :.", r".*inc {dest}.* ret;?"),
        r"(\w+)\s*--": (".: REG-- gadgets :.", r".*dec {dest}.* ret;?"),
        r"neg\s+(\w+)": (".: NEG gadgets :.", r".*neg {dest}.* ret;?")
    }

    # Identify the semantic type and search for a direct gadget if available
    for pattern, (category, gadget_pattern) in patterns.items():
        match = re.match(pattern, semantic)
        if match:
            groups = match.groups()
            if len(groups) == 2:
                dest, src = groups
                # Try to find a direct gadget for this semantic
                final_gadget = find_shortest_gadget(categories, category, gadget_pattern, debug, dest=dest, src=src)
                if not final_gadget:
                    debug_print(f"[DEBUG] No direct gadget found for {semantic}", debug)
                    # If no direct gadget, construct a chain of gadgets
                    return build_gadget_chain(categories, dest, src, category, gadget_pattern, debug)
                return [final_gadget]
            elif len(groups) == 1:
                dest = groups[0]
                final_gadget = find_shortest_gadget(categories, category, gadget_pattern, debug, dest=dest)
                return [final_gadget] if final_gadget else []
    debug_print("[DEBUG] Invalid or unsupported semantic format.", debug)
    return []

def build_gadget_chain(categories, dest_reg, src_reg, final_category, final_pattern_template, debug, max_depth=5):
    """
    Constructs a chain of gadgets starting with the final gadget that matches the specified semantic.
    Works backward from the destination register to reach the source register.
    """
    chains = []
    visited = set()

    def search_backward(current_reg, target_reg, current_chain, depth, is_final_gadget):
        nonlocal chains
        if depth > max_depth:
            return

        # If the chain is complete and we've reached src_reg, add to chains
        if current_reg == target_reg:
            chains.append(current_chain[:])
            return

        # Select category and pattern based on whether it's the final gadget or an intermediate one
        category = final_category if is_final_gadget else ".: REG1 <- REG2 gadgets :."
        pattern_template = final_pattern_template if is_final_gadget else r".*mov {dest}, {src}.* ret;?"

        # Iterate over possible intermediate registers to continue building the chain
        for intermediate_reg in ["eax", "ebx", "ecx", "edx", "esi", "edi"]:
            if intermediate_reg == current_reg or intermediate_reg in visited:
                continue

            visited.add(intermediate_reg)
            preceding_gadget = find_shortest_gadget(categories, category, pattern_template, debug, dest=current_reg, src=intermediate_reg)
            if preceding_gadget:
                # Add the gadget to the chain and continue searching
                new_chain = [preceding_gadget] + current_chain
                search_backward(intermediate_reg, target_reg, new_chain, depth + 1, is_final_gadget=False)
            visited.remove(intermediate_reg)

    # Start the chain with the final gadget in the specified category for the semantic
    search_backward(dest_reg, src_reg, [], 0, is_final_gadget=True)

    # Return the shortest chain that matches the requested semantic
    return min(chains, key=len) if chains else []